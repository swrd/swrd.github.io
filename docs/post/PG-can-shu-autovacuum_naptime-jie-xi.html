<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/5057571?s=96&v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="
## PG autovacuum_naptime 介绍

autovacuum_naptime 参数官方文档描述如下：

```yaml
Specifies the minimum delay between autovacuum runs on any given database. In each round the daemon examines the database and issues VACUUM and ANALYZE commands as needed for tables in that database. If this value is specified without units, it is taken as seconds. The default is one minute (1min). This parameter can only be set in the postgresql.conf file or on the server command line.
```

## autovacuum_naptime 源码分析

根据官方文档感觉了解总是不彻底，下面根据代码分析一下该参数。">
<meta property="og:title" content="PG参数autovacuum_naptime解析">
<meta property="og:description" content="
## PG autovacuum_naptime 介绍

autovacuum_naptime 参数官方文档描述如下：

```yaml
Specifies the minimum delay between autovacuum runs on any given database. In each round the daemon examines the database and issues VACUUM and ANALYZE commands as needed for tables in that database. If this value is specified without units, it is taken as seconds. The default is one minute (1min). This parameter can only be set in the postgresql.conf file or on the server command line.
```

## autovacuum_naptime 源码分析

根据官方文档感觉了解总是不彻底，下面根据代码分析一下该参数。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://swrd.github.io/post/PG-can-shu-autovacuum_naptime-jie-xi.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/5057571?s=96&v=4">
<title>PG参数autovacuum_naptime解析</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">PG参数autovacuum_naptime解析</h1>
<div class="title-right">
    <a href="https://swrd.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/swrd/swrd.github.io/issues/7" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>PG autovacuum_naptime 介绍</h2>
<p>autovacuum_naptime 参数官方文档描述如下：</p>
<div class="highlight highlight-source-yaml"><pre class="notranslate"><span class="pl-s">Specifies the minimum delay between autovacuum runs on any given database. In each round the daemon examines the database and issues VACUUM and ANALYZE commands as needed for tables in that database. If this value is specified without units, it is taken as seconds. The default is one minute (1min). This parameter can only be set in the postgresql.conf file or on the server command line.</span></pre></div>
<h2>autovacuum_naptime 源码分析</h2>
<p>根据官方文档感觉了解总是不彻底，下面根据代码分析一下该参数。</p>
<p>涉及到的函数调用关系：</p>
<div class="highlight highlight-source-sql"><pre class="notranslate">A[AutoVacLauncherMain] <span class="pl-c"><span class="pl-c">--</span>&gt; B(launcher_determine_sleep)</span>
    B <span class="pl-c"><span class="pl-c">--</span>&gt; C[rebuild_database_list]</span></pre></div>
<p><code class="notranslate">AutoVacLauncherMain</code>是vacuum launcher主函数，循环调用<code class="notranslate">launcher_determine_sleep</code>函数判断延迟多久调用<code class="notranslate">vacuum worker</code>：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/*</span>
<span class="pl-c"> * Main loop for the autovacuum launcher process.</span>
<span class="pl-c"> */</span>
<span class="pl-smi">NON_EXEC_STATIC</span> <span class="pl-s1">void</span>
<span class="pl-en">AutoVacLauncherMain</span>(<span class="pl-smi">int</span> <span class="pl-s1">argc</span>, <span class="pl-smi">char</span> <span class="pl-c1">*</span><span class="pl-s1">argv</span>[])
{
	...
   
	<span class="pl-c">/* loop until shutdown request */</span>
	<span class="pl-k">while</span> (!<span class="pl-s1">ShutdownRequestPending</span>)
	{
		<span class="pl-k">struct</span> <span class="pl-smi">timeval</span> <span class="pl-s1">nap</span>;
		<span class="pl-smi">TimestampTz</span> <span class="pl-s1">current_time</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
		<span class="pl-smi">bool</span>		<span class="pl-s1">can_launch</span>;

		<span class="pl-c">/*</span>
<span class="pl-c">		 * This loop is a bit different from the normal use of WaitLatch,</span>
<span class="pl-c">		 * because we'd like to sleep before the first launch of a child</span>
<span class="pl-c">		 * process.  So it's WaitLatch, then ResetLatch, then check for</span>
<span class="pl-c">		 * wakening conditions.</span>
<span class="pl-c">		 */</span>

		<span class="pl-en">launcher_determine_sleep</span>(!<span class="pl-en">dlist_is_empty</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">AutoVacuumShmem</span><span class="pl-c1">-&gt;</span><span class="pl-c1">av_freeWorkers</span>),
								 false, <span class="pl-c1">&amp;</span><span class="pl-s1">nap</span>);

		<span class="pl-c">/*</span>
<span class="pl-c">		 * Wait until naptime expires or we get some type of signal (all the</span>
<span class="pl-c">		 * signal handlers will wake us by calling SetLatch).</span>
<span class="pl-c">		 */</span>
		(<span class="pl-smi">void</span>) <span class="pl-en">WaitLatch</span>(<span class="pl-s1">MyLatch</span>,
						 <span class="pl-c1">WL_LATCH_SET</span> | <span class="pl-c1">WL_TIMEOUT</span> | <span class="pl-c1">WL_EXIT_ON_PM_DEATH</span>,
						 (<span class="pl-s1">nap</span>.<span class="pl-c1">tv_sec</span> <span class="pl-c1">*</span> <span class="pl-c1">1000L</span>) <span class="pl-c1">+</span> (<span class="pl-s1">nap</span>.<span class="pl-c1">tv_usec</span> / <span class="pl-c1">1000L</span>),
						 <span class="pl-c1">WAIT_EVENT_AUTOVACUUM_MAIN</span>);

		<span class="pl-en">ResetLatch</span>(<span class="pl-s1">MyLatch</span>);

		<span class="pl-en">HandleAutoVacLauncherInterrupts</span>();
        ....
}</pre></div>
<p>在<code class="notranslate">launcher_determine_sleep</code>函数中，当存在有空闲的vacuum worker时，则会延迟<code class="notranslate">autovacuum_naptime</code>后调用，如果没有空闲worker，则会根据获取的数据库列表的avl_dbase中的adl_score分数来降序执行，分数高的先执行。</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/*</span>
<span class="pl-c"> * Determine the time to sleep, based on the database list.</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * The "canlaunch" parameter indicates whether we can start a worker right now,</span>
<span class="pl-c"> * for example due to the workers being all busy.  If this is false, we will</span>
<span class="pl-c"> * cause a long sleep, which will be interrupted when a worker exits.</span>
<span class="pl-c"> */</span>
<span class="pl-k">static</span> <span class="pl-smi">void</span>
<span class="pl-en">launcher_determine_sleep</span>(<span class="pl-smi">bool</span> <span class="pl-s1">canlaunch</span>, <span class="pl-smi">bool</span> <span class="pl-s1">recursing</span>, <span class="pl-k">struct</span> <span class="pl-smi">timeval</span> <span class="pl-c1">*</span><span class="pl-s1">nap</span>)
{
	<span class="pl-c">/*</span>
<span class="pl-c">	 * We sleep until the next scheduled vacuum.  We trust that when the</span>
<span class="pl-c">	 * database list was built, care was taken so that no entries have times</span>
<span class="pl-c">	 * in the past; if the first entry has too close a next_worker value, or a</span>
<span class="pl-c">	 * time in the past, we will sleep a small nominal time.</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (!<span class="pl-s1">canlaunch</span>)
	{
		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_sec</span> <span class="pl-c1">=</span> <span class="pl-s1">autovacuum_naptime</span>;
		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_usec</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
	}
	<span class="pl-k">else</span> <span class="pl-k">if</span> (!<span class="pl-en">dlist_is_empty</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">DatabaseList</span>))
	{
		<span class="pl-smi">TimestampTz</span> <span class="pl-s1">current_time</span> <span class="pl-c1">=</span> <span class="pl-en">GetCurrentTimestamp</span>();
		<span class="pl-smi">TimestampTz</span> <span class="pl-s1">next_wakeup</span>;
		<span class="pl-smi">avl_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">avdb</span>;
		<span class="pl-smi">long</span>		<span class="pl-s1">secs</span>;
		<span class="pl-smi">int</span>			<span class="pl-s1">usecs</span>;

		<span class="pl-s1">avdb</span> <span class="pl-c1">=</span> <span class="pl-en">dlist_tail_element</span>(<span class="pl-s1">avl_dbase</span>, <span class="pl-s1">adl_node</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">DatabaseList</span>);

		<span class="pl-s1">next_wakeup</span> <span class="pl-c1">=</span> <span class="pl-s1">avdb</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_next_worker</span>;
		<span class="pl-en">TimestampDifference</span>(<span class="pl-s1">current_time</span>, <span class="pl-s1">next_wakeup</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">secs</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">usecs</span>);

		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_sec</span> <span class="pl-c1">=</span> <span class="pl-s1">secs</span>;
		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_usec</span> <span class="pl-c1">=</span> <span class="pl-s1">usecs</span>;
	}
	<span class="pl-k">else</span>
	{
		<span class="pl-c">/* list is empty, sleep for whole autovacuum_naptime seconds  */</span>
		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_sec</span> <span class="pl-c1">=</span> <span class="pl-s1">autovacuum_naptime</span>;
		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_usec</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
	}

	<span class="pl-c">/*</span>
<span class="pl-c">	 * If the result is exactly zero, it means a database had an entry with</span>
<span class="pl-c">	 * time in the past.  Rebuild the list so that the databases are evenly</span>
<span class="pl-c">	 * distributed again, and recalculate the time to sleep.  This can happen</span>
<span class="pl-c">	 * if there are more tables needing vacuum than workers, and they all take</span>
<span class="pl-c">	 * longer to vacuum than autovacuum_naptime.</span>
<span class="pl-c">	 *</span>
<span class="pl-c">	 * We only recurse once.  rebuild_database_list should always return times</span>
<span class="pl-c">	 * in the future, but it seems best not to trust too much on that.</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_sec</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_usec</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span> <span class="pl-c1">&amp;&amp;</span> !<span class="pl-s1">recursing</span>)
	{
		<span class="pl-en">rebuild_database_list</span>(<span class="pl-s1">InvalidOid</span>);
		<span class="pl-en">launcher_determine_sleep</span>(<span class="pl-s1">canlaunch</span>, true, <span class="pl-s1">nap</span>);
		<span class="pl-k">return</span>;
	}

	<span class="pl-c">/* The smallest time we'll allow the launcher to sleep. */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_sec</span> &lt;= <span class="pl-c1">0</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_usec</span> &lt;= <span class="pl-c1">MIN_AUTOVAC_SLEEPTIME</span> <span class="pl-c1">*</span> <span class="pl-c1">1000</span>)
	{
		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_sec</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_usec</span> <span class="pl-c1">=</span> <span class="pl-c1">MIN_AUTOVAC_SLEEPTIME</span> <span class="pl-c1">*</span> <span class="pl-c1">1000</span>;
	}

	<span class="pl-c">/*</span>
<span class="pl-c">	 * If the sleep time is too large, clamp it to an arbitrary maximum (plus</span>
<span class="pl-c">	 * any fractional seconds, for simplicity).  This avoids an essentially</span>
<span class="pl-c">	 * infinite sleep in strange cases like the system clock going backwards a</span>
<span class="pl-c">	 * few years.</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_sec</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">MAX_AUTOVAC_SLEEPTIME</span>)
		<span class="pl-s1">nap</span><span class="pl-c1">-&gt;</span><span class="pl-c1">tv_sec</span> <span class="pl-c1">=</span> <span class="pl-c1">MAX_AUTOVAC_SLEEPTIME</span>;
}</pre></div>
<p>rebuild_database_list函数：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/*</span>
<span class="pl-c"> * Build an updated DatabaseList.  It must only contain databases that appear</span>
<span class="pl-c"> * in pgstats, and must be sorted by next_worker from highest to lowest,</span>
<span class="pl-c"> * distributed regularly across the next autovacuum_naptime interval.</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * Receives the Oid of the database that made this list be generated (we call</span>
<span class="pl-c"> * this the "new" database, because when the database was already present on</span>
<span class="pl-c"> * the list, we expect that this function is not called at all).  The</span>
<span class="pl-c"> * preexisting list, if any, will be used to preserve the order of the</span>
<span class="pl-c"> * databases in the autovacuum_naptime period.  The new database is put at the</span>
<span class="pl-c"> * end of the interval.  The actual values are not saved, which should not be</span>
<span class="pl-c"> * much of a problem.</span>
<span class="pl-c"> */</span>
<span class="pl-k">static</span> <span class="pl-smi">void</span>
<span class="pl-en">rebuild_database_list</span>(<span class="pl-smi">Oid</span> <span class="pl-s1">newdb</span>)
{
	<span class="pl-smi">List</span>	   <span class="pl-c1">*</span><span class="pl-s1">dblist</span>;
	<span class="pl-smi">ListCell</span>   <span class="pl-c1">*</span><span class="pl-s1">cell</span>;
	<span class="pl-smi">MemoryContext</span> <span class="pl-s1">newcxt</span>;
	<span class="pl-smi">MemoryContext</span> <span class="pl-s1">oldcxt</span>;
	<span class="pl-smi">MemoryContext</span> <span class="pl-s1">tmpcxt</span>;
	<span class="pl-smi">HASHCTL</span>		<span class="pl-s1">hctl</span>;
	<span class="pl-smi">int</span>			<span class="pl-s1">score</span>;
	<span class="pl-smi">int</span>			<span class="pl-s1">nelems</span>;
	<span class="pl-smi">HTAB</span>	   <span class="pl-c1">*</span><span class="pl-s1">dbhash</span>;
	<span class="pl-smi">dlist_iter</span>	<span class="pl-s1">iter</span>;

	<span class="pl-c">/* use fresh stats */</span>
	<span class="pl-en">autovac_refresh_stats</span>();

	<span class="pl-s1">newcxt</span> <span class="pl-c1">=</span> <span class="pl-en">AllocSetContextCreate</span>(<span class="pl-s1">AutovacMemCxt</span>,
								   <span class="pl-s">"AV dblist"</span>,
								   <span class="pl-c1">ALLOCSET_DEFAULT_SIZES</span>);
	<span class="pl-s1">tmpcxt</span> <span class="pl-c1">=</span> <span class="pl-en">AllocSetContextCreate</span>(<span class="pl-s1">newcxt</span>,
								   <span class="pl-s">"tmp AV dblist"</span>,
								   <span class="pl-c1">ALLOCSET_DEFAULT_SIZES</span>);
	<span class="pl-s1">oldcxt</span> <span class="pl-c1">=</span> <span class="pl-en">MemoryContextSwitchTo</span>(<span class="pl-s1">tmpcxt</span>);

	<span class="pl-c">/*</span>
<span class="pl-c">	 * Implementing this is not as simple as it sounds, because we need to put</span>
<span class="pl-c">	 * the new database at the end of the list; next the databases that were</span>
<span class="pl-c">	 * already on the list, and finally (at the tail of the list) all the</span>
<span class="pl-c">	 * other databases that are not on the existing list.</span>
<span class="pl-c">	 *</span>
<span class="pl-c">	 * To do this, we build an empty hash table of scored databases.  We will</span>
<span class="pl-c">	 * start with the lowest score (zero) for the new database, then</span>
<span class="pl-c">	 * increasing scores for the databases in the existing list, in order, and</span>
<span class="pl-c">	 * lastly increasing scores for all databases gotten via</span>
<span class="pl-c">	 * get_database_list() that are not already on the hash.</span>
<span class="pl-c">	 *</span>
<span class="pl-c">	 * Then we will put all the hash elements into an array, sort the array by</span>
<span class="pl-c">	 * score, and finally put the array elements into the new doubly linked</span>
<span class="pl-c">	 * list.</span>
<span class="pl-c">	 */</span>
	<span class="pl-s1">hctl</span>.<span class="pl-c1">keysize</span> <span class="pl-c1">=</span> <span class="pl-k">sizeof</span>(<span class="pl-s1">Oid</span>);
	<span class="pl-s1">hctl</span>.<span class="pl-c1">entrysize</span> <span class="pl-c1">=</span> <span class="pl-k">sizeof</span>(<span class="pl-s1">avl_dbase</span>);
	<span class="pl-s1">hctl</span>.<span class="pl-c1">hcxt</span> <span class="pl-c1">=</span> <span class="pl-s1">tmpcxt</span>;
	<span class="pl-s1">dbhash</span> <span class="pl-c1">=</span> <span class="pl-en">hash_create</span>(<span class="pl-s">"db hash"</span>, <span class="pl-c1">20</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">hctl</span>,	<span class="pl-c">/* magic number here FIXME */</span>
						 <span class="pl-c1">HASH_ELEM</span> | <span class="pl-c1">HASH_BLOBS</span> | <span class="pl-c1">HASH_CONTEXT</span>);

	<span class="pl-c">/* start by inserting the new database */</span>
	<span class="pl-s1">score</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
	<span class="pl-k">if</span> (<span class="pl-en">OidIsValid</span>(<span class="pl-s1">newdb</span>))
	{
		<span class="pl-smi">avl_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">db</span>;
		<span class="pl-smi">PgStat_StatDBEntry</span> <span class="pl-c1">*</span><span class="pl-s1">entry</span>;

		<span class="pl-c">/* only consider this database if it has a pgstat entry */</span>
		<span class="pl-s1">entry</span> <span class="pl-c1">=</span> <span class="pl-en">pgstat_fetch_stat_dbentry</span>(<span class="pl-s1">newdb</span>);
		<span class="pl-k">if</span> (<span class="pl-s1">entry</span> <span class="pl-c1">!=</span> <span class="pl-c1">NULL</span>)
		{
			<span class="pl-c">/* we assume it isn't found because the hash was just created */</span>
			<span class="pl-s1">db</span> <span class="pl-c1">=</span> <span class="pl-en">hash_search</span>(<span class="pl-s1">dbhash</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">newdb</span>, <span class="pl-c1">HASH_ENTER</span>, <span class="pl-c1">NULL</span>);

			<span class="pl-c">/* hash_search already filled in the key */</span>
			<span class="pl-s1">db</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_score</span> <span class="pl-c1">=</span> <span class="pl-s1">score</span><span class="pl-c1">++</span>;
			<span class="pl-c">/* next_worker is filled in later */</span>
		}
	}

	<span class="pl-c">/* Now insert the databases from the existing list */</span>
	<span class="pl-en">dlist_foreach</span>(<span class="pl-s1">iter</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">DatabaseList</span>)
	{
		<span class="pl-smi">avl_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">avdb</span> <span class="pl-c1">=</span> <span class="pl-en">dlist_container</span>(<span class="pl-s1">avl_dbase</span>, <span class="pl-s1">adl_node</span>, <span class="pl-s1">iter</span>.<span class="pl-c1">cur</span>);
		<span class="pl-smi">avl_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">db</span>;
		<span class="pl-smi">bool</span>		<span class="pl-s1">found</span>;
		<span class="pl-smi">PgStat_StatDBEntry</span> <span class="pl-c1">*</span><span class="pl-s1">entry</span>;

		<span class="pl-c">/*</span>
<span class="pl-c">		 * skip databases with no stat entries -- in particular, this gets rid</span>
<span class="pl-c">		 * of dropped databases</span>
<span class="pl-c">		 */</span>
		<span class="pl-s1">entry</span> <span class="pl-c1">=</span> <span class="pl-en">pgstat_fetch_stat_dbentry</span>(<span class="pl-s1">avdb</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_datid</span>);
		<span class="pl-k">if</span> (<span class="pl-s1">entry</span> <span class="pl-c1">==</span> <span class="pl-c1">NULL</span>)
			<span class="pl-k">continue</span>;

		<span class="pl-s1">db</span> <span class="pl-c1">=</span> <span class="pl-en">hash_search</span>(<span class="pl-s1">dbhash</span>, <span class="pl-c1">&amp;</span>(<span class="pl-s1">avdb</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_datid</span>), <span class="pl-c1">HASH_ENTER</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">found</span>);

		<span class="pl-k">if</span> (!<span class="pl-s1">found</span>)
		{
			<span class="pl-c">/* hash_search already filled in the key */</span>
			<span class="pl-s1">db</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_score</span> <span class="pl-c1">=</span> <span class="pl-s1">score</span><span class="pl-c1">++</span>;
			<span class="pl-c">/* next_worker is filled in later */</span>
		}
	}

	<span class="pl-c">/* finally, insert all qualifying databases not previously inserted */</span>
	<span class="pl-s1">dblist</span> <span class="pl-c1">=</span> <span class="pl-en">get_database_list</span>();
	<span class="pl-en">foreach</span>(<span class="pl-s1">cell</span>, <span class="pl-s1">dblist</span>)
	{
		<span class="pl-smi">avw_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">avdb</span> <span class="pl-c1">=</span> <span class="pl-en">lfirst</span>(<span class="pl-s1">cell</span>);
		<span class="pl-smi">avl_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">db</span>;
		<span class="pl-smi">bool</span>		<span class="pl-s1">found</span>;
		<span class="pl-smi">PgStat_StatDBEntry</span> <span class="pl-c1">*</span><span class="pl-s1">entry</span>;

		<span class="pl-c">/* only consider databases with a pgstat entry */</span>
		<span class="pl-s1">entry</span> <span class="pl-c1">=</span> <span class="pl-en">pgstat_fetch_stat_dbentry</span>(<span class="pl-s1">avdb</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adw_datid</span>);
		<span class="pl-k">if</span> (<span class="pl-s1">entry</span> <span class="pl-c1">==</span> <span class="pl-c1">NULL</span>)
			<span class="pl-k">continue</span>;

		<span class="pl-s1">db</span> <span class="pl-c1">=</span> <span class="pl-en">hash_search</span>(<span class="pl-s1">dbhash</span>, <span class="pl-c1">&amp;</span>(<span class="pl-s1">avdb</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adw_datid</span>), <span class="pl-c1">HASH_ENTER</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">found</span>);
		<span class="pl-c">/* only update the score if the database was not already on the hash */</span>
		<span class="pl-k">if</span> (!<span class="pl-s1">found</span>)
		{
			<span class="pl-c">/* hash_search already filled in the key */</span>
			<span class="pl-s1">db</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_score</span> <span class="pl-c1">=</span> <span class="pl-s1">score</span><span class="pl-c1">++</span>;
			<span class="pl-c">/* next_worker is filled in later */</span>
		}
	}
	<span class="pl-s1">nelems</span> <span class="pl-c1">=</span> <span class="pl-s1">score</span>;

	<span class="pl-c">/* from here on, the allocated memory belongs to the new list */</span>
	<span class="pl-en">MemoryContextSwitchTo</span>(<span class="pl-s1">newcxt</span>);
	<span class="pl-en">dlist_init</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">DatabaseList</span>);

	<span class="pl-k">if</span> (<span class="pl-s1">nelems</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span>)
	{
		<span class="pl-smi">TimestampTz</span> <span class="pl-s1">current_time</span>;
		<span class="pl-smi">int</span>			<span class="pl-s1">millis_increment</span>;
		<span class="pl-smi">avl_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">dbary</span>;
		<span class="pl-smi">avl_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">db</span>;
		<span class="pl-smi">HASH_SEQ_STATUS</span> <span class="pl-s1">seq</span>;
		<span class="pl-smi">int</span>			<span class="pl-s1">i</span>;

		<span class="pl-c">/* put all the hash elements into an array */</span>
		<span class="pl-s1">dbary</span> <span class="pl-c1">=</span> <span class="pl-en">palloc</span>(<span class="pl-s1">nelems</span> <span class="pl-c1">*</span> <span class="pl-k">sizeof</span>(<span class="pl-s1">avl_dbase</span>));

		<span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
		<span class="pl-en">hash_seq_init</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">seq</span>, <span class="pl-s1">dbhash</span>);
		<span class="pl-k">while</span> ((<span class="pl-s1">db</span> <span class="pl-c1">=</span> <span class="pl-en">hash_seq_search</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">seq</span>)) <span class="pl-c1">!=</span> <span class="pl-c1">NULL</span>)
			<span class="pl-en">memcpy</span>(<span class="pl-c1">&amp;</span>(<span class="pl-s1">dbary</span>[<span class="pl-s1">i</span><span class="pl-c1">++</span>]), <span class="pl-s1">db</span>, <span class="pl-k">sizeof</span>(<span class="pl-s1">avl_dbase</span>));

		<span class="pl-c">/* sort the array */</span>
		<span class="pl-en">qsort</span>(<span class="pl-s1">dbary</span>, <span class="pl-s1">nelems</span>, <span class="pl-k">sizeof</span>(<span class="pl-s1">avl_dbase</span>), <span class="pl-s1">db_comparator</span>);

		<span class="pl-c">/*</span>
<span class="pl-c">		 * Determine the time interval between databases in the schedule. If</span>
<span class="pl-c">		 * we see that the configured naptime would take us to sleep times</span>
<span class="pl-c">		 * lower than our min sleep time (which launcher_determine_sleep is</span>
<span class="pl-c">		 * coded not to allow), silently use a larger naptime (but don't touch</span>
<span class="pl-c">		 * the GUC variable).</span>
<span class="pl-c">		 */</span>
		<span class="pl-s1">millis_increment</span> <span class="pl-c1">=</span> <span class="pl-c1">1000.0</span> <span class="pl-c1">*</span> <span class="pl-s1">autovacuum_naptime</span> / <span class="pl-s1">nelems</span>;
		<span class="pl-k">if</span> (<span class="pl-s1">millis_increment</span> &lt;= <span class="pl-c1">MIN_AUTOVAC_SLEEPTIME</span>)
			<span class="pl-s1">millis_increment</span> <span class="pl-c1">=</span> <span class="pl-c1">MIN_AUTOVAC_SLEEPTIME</span> <span class="pl-c1">*</span> <span class="pl-c1">1.1</span>;

		<span class="pl-s1">current_time</span> <span class="pl-c1">=</span> <span class="pl-en">GetCurrentTimestamp</span>();

		<span class="pl-c">/*</span>
<span class="pl-c">		 * move the elements from the array into the dlist, setting the</span>
<span class="pl-c">		 * next_worker while walking the array</span>
<span class="pl-c">		 */</span>
		<span class="pl-k">for</span> (<span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">nelems</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>)
		{
			<span class="pl-smi">avl_dbase</span>  <span class="pl-c1">*</span><span class="pl-s1">db</span> <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span>(<span class="pl-s1">dbary</span>[<span class="pl-s1">i</span>]);

			<span class="pl-s1">current_time</span> <span class="pl-c1">=</span> <span class="pl-en">TimestampTzPlusMilliseconds</span>(<span class="pl-s1">current_time</span>,
													   <span class="pl-s1">millis_increment</span>);
			<span class="pl-s1">db</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_next_worker</span> <span class="pl-c1">=</span> <span class="pl-s1">current_time</span>;

			<span class="pl-c">/* later elements should go closer to the head of the list */</span>
			<span class="pl-en">dlist_push_head</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">DatabaseList</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">db</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_node</span>);
		}
	}

	<span class="pl-c">/* all done, clean up memory */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">DatabaseListCxt</span> <span class="pl-c1">!=</span> <span class="pl-c1">NULL</span>)
		<span class="pl-en">MemoryContextDelete</span>(<span class="pl-s1">DatabaseListCxt</span>);
	<span class="pl-en">MemoryContextDelete</span>(<span class="pl-s1">tmpcxt</span>);
	<span class="pl-s1">DatabaseListCxt</span> <span class="pl-c1">=</span> <span class="pl-s1">newcxt</span>;
	<span class="pl-en">MemoryContextSwitchTo</span>(<span class="pl-s1">oldcxt</span>);
}</pre></div>
<p>由于可能存在新增的或是删除的数据库，所以需要重建数据库列表，获取到数据库个数N后，autovacuum_naptime/N 则为 vacuum worker延迟执行的时间，下面则为代码说明，nelems表示数据库的个数：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-s1">millis_increment</span> <span class="pl-c1">=</span> <span class="pl-c1">1000.0</span> <span class="pl-c1">*</span> <span class="pl-s1">autovacuum_naptime</span> / <span class="pl-s1">nelems</span>;
<span class="pl-k">if</span> (<span class="pl-s1">millis_increment</span> &lt;= <span class="pl-c1">MIN_AUTOVAC_SLEEPTIME</span>)
	<span class="pl-s1">millis_increment</span> <span class="pl-c1">=</span> <span class="pl-c1">MIN_AUTOVAC_SLEEPTIME</span> <span class="pl-c1">*</span> <span class="pl-c1">1.1</span>;</pre></div>
<p>在重建数据库列表时，对于没有统计信息的数据库则会跳过，对于数据库对应的adl_score分数，则是根据加入列表中加入顺序累计递增的：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">// 第一阶段：新数据库（参数传入）</span>
<span class="pl-k">if</span> (<span class="pl-en">OidIsValid</span>(<span class="pl-s1">newdb</span>)) {
    <span class="pl-s1">db</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_score</span> <span class="pl-c1">=</span> <span class="pl-s1">score</span><span class="pl-c1">++</span>;  <span class="pl-c">// 初始评分=0，逐步递增</span>
}

<span class="pl-c">// 第二阶段：现有数据库列表</span>
<span class="pl-en">dlist_foreach</span>(<span class="pl-s1">iter</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">DatabaseList</span>) {
    <span class="pl-k">if</span> (!<span class="pl-s1">found</span>) <span class="pl-s1">db</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_score</span> <span class="pl-c1">=</span> <span class="pl-s1">score</span><span class="pl-c1">++</span>;  <span class="pl-c">// 延续递增</span>
}

<span class="pl-c">// 第三阶段：全量数据库遍历</span>
<span class="pl-s1">dblist</span> <span class="pl-c1">=</span> <span class="pl-en">get_database_list</span>();
<span class="pl-en">foreach</span>(<span class="pl-s1">cell</span>, <span class="pl-s1">dblist</span>) {
    <span class="pl-k">if</span> (!<span class="pl-s1">found</span>) <span class="pl-s1">db</span><span class="pl-c1">-&gt;</span><span class="pl-c1">adl_score</span> <span class="pl-c1">=</span> <span class="pl-s1">score</span><span class="pl-c1">++</span>;  <span class="pl-c">// 继续递增</span>
}</pre></div>
<p>递增分配 ：每个新插入哈希表的数据库获得递增的整数值</p>
<p>插入顺序 ：</p>
<ul>
<li>新请求的数据库（ newdb ）优先获得低分</li>
<li>现有数据库列表中的数据库次之</li>
<li>全局数据库列表中的未调度数据库最后</li>
</ul>
<p>排序规则 ：通过 db_comparator 按分数 降序 排列（高分在前）</p>
<p>这样安排可以保证每个数据库都可以执行到vacuum，新数据库不会抢占现有数据库的资源，长期未调度的数据库通过高分获得优先处理。</p>
<p>autovacuum_naptime 参数是1min，官方文档中并没有限制该参数的范围值，但是代码中限制了可用范围是100ms到300s之间。</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* the minimum allowed time between two awakenings of the launcher */</span>
<span class="pl-k">#define</span> <span class="pl-c1">MIN_AUTOVAC_SLEEPTIME</span> 100.0 <span class="pl-c">/* milliseconds */</span>
<span class="pl-k">#define</span> <span class="pl-c1">MAX_AUTOVAC_SLEEPTIME</span> 300	<span class="pl-c">/* seconds */</span></pre></div>
<h2>总结</h2>
<ul>
<li>
<p>autovacuum_naptime 的含义并不是间隔多久后执行vacuum/analyze达到条件表的频率，而是检查是否存在需要vacuum或analyze表的频率，如果没有则直接退出</p>
</li>
<li>
<p>vacuum 定期调用间隔和当前有无空闲worker有关：</p>
<ul>
<li>有空闲worker，则在间隔autovacuum_naptime 后执行</li>
<li>无空闲worker时，则会在间隔 <code class="notranslate">autovacuum_naptime /数据库个数</code> 后执行</li>
</ul>
</li>
<li>
<p>autovacuum_naptime 时间范围在代码中做了约束，可用的范围是100ms--300s</p>
</li>
<li>
<p>vacuum的执行根据数据库的分数倒序执行，越久没执行的数据则会越先执行</p>
</li>
<li>
<p>对于数据库比较多的实例，可能会出现autovacuum launcher进程CPU飙升的情况，如果数据库实例并不活跃，没有多少需要执行vacuum或analyze的表可以将 autovacuum_naptime  调大一些</p>
</li>
</ul>
<h2>参考</h2>
<p>PG 14.4/autovacuum.c/AutoVacLauncherMain</p>
<p>PG 14.4/autovacuum.c/launcher_determine_sleep</p>
<p>PG 14.4/autovacuum.c/rebuild_database_list</p>
<p><a href="https://rhaas.blogspot.com/2019/02/tuning-autovacuumnaptime.html" rel="nofollow">https://rhaas.blogspot.com/2019/02/tuning-autovacuumnaptime.html</a></p>
<p><a href="https://github.com/digoal/blog/blob/master/201310/20131010_02.md">https://github.com/digoal/blog/blob/master/201310/20131010_02.md</a></p></div>
<div style="font-size:small;margin-top:8px;float:right;">❤️ 转载文章请注明出处，谢谢！❤️</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://swrd.github.io">PGStone</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("12/07/2024"!=""){
    var startSite=new Date("12/07/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek main https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.disabled=true;
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","swrd/swrd.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script async src='https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js'></script>

</html>
