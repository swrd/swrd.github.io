<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://avatars.githubusercontent.com/u/5057571?s=96&v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## 1. 概述

### 1.1 什么是 Buffer Ring

PostgreSQL 的 Ring Buffer 是一种**后端私有的缓冲区访问策略**（Buffer Access Strategy），用于优化特定场景下的缓冲区使用。">
<meta property="og:title" content="PostgreSQL Ring  Buffer 机制详解">
<meta property="og:description" content="## 1. 概述

### 1.1 什么是 Buffer Ring

PostgreSQL 的 Ring Buffer 是一种**后端私有的缓冲区访问策略**（Buffer Access Strategy），用于优化特定场景下的缓冲区使用。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://swrd.github.io/post/PostgreSQL%20Ring%20%20Buffer%20-ji-zhi-xiang-jie.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/5057571?s=96&v=4">
<title>PostgreSQL Ring  Buffer 机制详解</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">PostgreSQL Ring  Buffer 机制详解</h1>
<div class="title-right">
    <a href="https://swrd.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/swrd/swrd.github.io/issues/14" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>1. 概述</h2>
<h3>1.1 什么是 Buffer Ring</h3>
<p>PostgreSQL 的 Ring Buffer 是一种<strong>后端私有的缓冲区访问策略</strong>（Buffer Access Strategy），用于优化特定场景下的缓冲区使用。它通过维护一个固定大小的环形缓冲区数组，避免大容量顺序扫描（如 VACUUM、批量读取/写入）污染全局缓冲池。</p>
<h3>1.2 设计目标</h3>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>目标</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>避免缓冲区污染</strong></td>
<td>大表扫描不应当逐出缓冲池中的热数据</td>
</tr>
<tr>
<td><strong>减少锁竞争</strong></td>
<td>Ring 是进程私有的，不需要全局锁</td>
</tr>
<tr>
<td><strong>优化批量操作</strong></td>
<td>批量读写可以更好地利用局部性原理</td>
</tr>
<tr>
<td><strong>保护正常查询</strong></td>
<td>VACUUM 等维护操作不应影响业务查询</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>1.3 核心思想</h3>
<p>传统 Buffer 分配使用全局的 Clock Sweep 算法。当执行大表扫描时，会频繁地逐出缓冲池中的页面，可能导致热数据被冷数据替换。</p>
<p>Buffer Ring 为特定操作分配一个<strong>固定大小的私有缓冲区集合</strong>，使这些操作在<strong>自己的 Ring 内循环使用</strong>，从而保护全局缓冲池。Ring Buffer 本质上是一个<strong>后端私有的 LRU 缓存</strong>，它从共享缓冲池中"借用"一定数量的缓冲区，并在操作期间循环使用这些缓冲区。</p>
<hr>
<h2>2. 核心数据结构</h2>
<h3>2.1 BufferAccessStrategyData</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件: src/backend/storage/buffer/freelist.c:71-97 */</span>

<span class="pl-c">/*</span>
<span class="pl-c"> * Private (non-shared) state for managing a ring of shared buffers to re-use.</span>
<span class="pl-c"> * This is currently the only kind of BufferAccessStrategy object, but someday</span>
<span class="pl-c"> * we might have more kinds.</span>
<span class="pl-c"> */</span>
<span class="pl-k">typedef</span> <span class="pl-k">struct</span> <span class="pl-smi">BufferAccessStrategyData</span>
{
    <span class="pl-c">/* 整体策略类型 */</span>
    <span class="pl-smi">BufferAccessStrategyType</span> <span class="pl-c1">btype</span>;

    <span class="pl-c">/* buffers[] 数组中的元素数量（环形大小） */</span>
    <span class="pl-smi">int</span>         <span class="pl-c1">ring_size</span>;

    <span class="pl-c">/*</span>
<span class="pl-c">     * 环形中"当前"槽位的索引</span>
<span class="pl-c">     * 即最近由 GetBufferFromRing 返回的槽位</span>
<span class="pl-c">     */</span>
    <span class="pl-smi">int</span>         <span class="pl-c1">current</span>;

    <span class="pl-c">/*</span>
<span class="pl-c">     * 如果 StrategyGetBuffer 刚返回的缓冲区已在环形中，则为 true</span>
<span class="pl-c">     */</span>
    <span class="pl-smi">bool</span>        <span class="pl-c1">current_was_in_ring</span>;

    <span class="pl-c">/*</span>
<span class="pl-c">     * 缓冲区编号数组</span>
<span class="pl-c">     * InvalidBuffer（即 0）表示尚未为此环形槽位选择缓冲区</span>
<span class="pl-c">     * 为了分配简便，此数组与结构的固定字段一起 palloc</span>
<span class="pl-c">     */</span>
    <span class="pl-smi">Buffer</span>      <span class="pl-c1">buffers</span>[<span class="pl-c1">FLEXIBLE_ARRAY_MEMBER</span>];
}<span class="pl-smi">BufferAccessStrategyData</span>;</pre></div>
<p><strong>字段说明</strong>:</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">btype</code></td>
<td><code class="notranslate">BufferAccessStrategyType</code></td>
<td>策略类型（NORMAL/BULKREAD/BULKWRITE/VACUUM）</td>
</tr>
<tr>
<td><code class="notranslate">ring_size</code></td>
<td><code class="notranslate">int</code></td>
<td>Ring 的大小（缓冲区数量）</td>
</tr>
<tr>
<td><code class="notranslate">current</code></td>
<td><code class="notranslate">int</code></td>
<td>当前指针位置，指向下一个要使用的槽位</td>
</tr>
<tr>
<td><code class="notranslate">current_was_in_ring</code></td>
<td><code class="notranslate">bool</code></td>
<td>标记当前 buffer 是否来自 ring</td>
</tr>
<tr>
<td><code class="notranslate">buffers[]</code></td>
<td><code class="notranslate">Buffer[]</code></td>
<td>柔性数组，存储 ring 中的缓冲区编号</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p><strong>BufferAccessStrategyData 内存布局</strong></p>
<p><strong>固定字段区域</strong> (偏移 0x00 - 0x0F)</p>
<pre class="notranslate"><code class="notranslate">+----------------------------+----------------------------+
| 字段名        | 类型     | 偏移  | 大小 |
|----------------------------|----------------------------|
| btype        | enum     | 0x00  | 4B  |
| ring_size    | int      | 0x04  | 4B  |
| current      | int      | 0x08  | 4B  |
| current_was_in_ring | bool | 0x0C  | 4B  |
+----------------------------+----------------------------+
</code></pre>
<p><strong>柔性数组区域</strong> (偏移 0x10 起始)</p>
<pre class="notranslate"><code class="notranslate">+----------------------------+
| buffers[0]                 |
| buffers[1]                 |
| ...                        |
| buffers[ring_size-1]       |
+----------------------------+
    总大小: ring_size × 4B
</code></pre>
<p><strong>总内存大小</strong> = <code class="notranslate">offsetof(BufferAccessStrategyData, buffers) + ring_size × sizeof(Buffer)</code></p>
<h3>2.2 BufferAccessStrategyType 枚举</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件: src/include/storage/bufmgr.h:27-34 */</span>
<span class="pl-c">/* Possible arguments for GetAccessStrategy() */</span>
<span class="pl-k">typedef</span> <span class="pl-k">enum</span> <span class="pl-smi">BufferAccessStrategyType</span>
{
    <span class="pl-c1">BAS_NORMAL</span>,      <span class="pl-c">/* 普通随机访问（返回 NULL，使用默认策略）*/</span>
    <span class="pl-c1">BAS_BULKREAD</span>,    <span class="pl-c">/* 大型只读扫描（更新 hint bits 是可以的）*/</span>
    <span class="pl-c1">BAS_BULKWRITE</span>,   <span class="pl-c">/* 大型多块写入（如 COPY IN）*/</span>
    <span class="pl-c1">BAS_VACUUM</span>       <span class="pl-c">/* VACUUM */</span>
} <span class="pl-smi">BufferAccessStrategyType</span>;</pre></div>
<hr>
<h2>3. Ring 大小配置</h2>
<h3>3.1 大小计算</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件: src/backend/storage/buffer/freelist.c:542-588 */</span>
<span class="pl-smi">BufferAccessStrategy</span>
<span class="pl-en">GetAccessStrategy</span>(<span class="pl-smi">BufferAccessStrategyType</span> <span class="pl-s1">btype</span>)
{
    <span class="pl-smi">BufferAccessStrategy</span> <span class="pl-s1">strategy</span>;
    <span class="pl-smi">int</span>         <span class="pl-s1">ring_size</span>;

    <span class="pl-c">// 根据类型选择环形大小</span>
    <span class="pl-k">switch</span> (<span class="pl-s1">btype</span>)
    {
        <span class="pl-k">case</span> <span class="pl-c1">BAS_NORMAL</span>:
            <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;  <span class="pl-c">/* 返回 NULL 表示使用默认策略 */</span>

        <span class="pl-k">case</span> <span class="pl-c1">BAS_BULKREAD</span>:
            <span class="pl-s1">ring_size</span> <span class="pl-c1">=</span> <span class="pl-c1">256</span> <span class="pl-c1">*</span> <span class="pl-c1">1024</span> / <span class="pl-c1">BLCKSZ</span>;  <span class="pl-c">// 256KB</span>
            <span class="pl-k">break</span>;
        <span class="pl-k">case</span> <span class="pl-c1">BAS_BULKWRITE</span>:
            <span class="pl-s1">ring_size</span> <span class="pl-c1">=</span> <span class="pl-c1">16</span> <span class="pl-c1">*</span> <span class="pl-c1">1024</span> <span class="pl-c1">*</span> <span class="pl-c1">1024</span> / <span class="pl-c1">BLCKSZ</span>;  <span class="pl-c">// 16MB</span>
            <span class="pl-k">break</span>;
        <span class="pl-k">case</span> <span class="pl-c1">BAS_VACUUM</span>:
            <span class="pl-s1">ring_size</span> <span class="pl-c1">=</span> <span class="pl-c1">256</span> <span class="pl-c1">*</span> <span class="pl-c1">1024</span> / <span class="pl-c1">BLCKSZ</span>;  <span class="pl-c">// 256KB</span>
            <span class="pl-k">break</span>;

        <span class="pl-k">default</span>:
            <span class="pl-en">elog</span>(<span class="pl-c1">ERROR</span>, <span class="pl-s">"unrecognized buffer access strategy: %d"</span>, (<span class="pl-smi">int</span>) <span class="pl-s1">btype</span>);
            <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
    }

    <span class="pl-c">/* 确保环形不会占用共享缓冲区的过大比例 */</span>
    <span class="pl-s1">ring_size</span> <span class="pl-c1">=</span> <span class="pl-en">Min</span>(<span class="pl-s1">NBuffers</span> / <span class="pl-c1">8</span>, <span class="pl-s1">ring_size</span>);

    <span class="pl-c">/* 分配对象并将所有元素初始化为零 */</span>
    <span class="pl-s1">strategy</span> <span class="pl-c1">=</span> (<span class="pl-smi">BufferAccessStrategy</span>)
        <span class="pl-en">palloc0</span>(offsetof(<span class="pl-smi">BufferAccessStrategyData</span>, <span class="pl-c1">buffers</span>) <span class="pl-c1">+</span>
                 <span class="pl-s1">ring_size</span> <span class="pl-c1">*</span> <span class="pl-k">sizeof</span>(<span class="pl-s1">Buffer</span>));

    <span class="pl-c">/* 设置非零字段 */</span>
    <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">btype</span> <span class="pl-c1">=</span> <span class="pl-s1">btype</span>;
    <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ring_size</span> <span class="pl-c1">=</span> <span class="pl-s1">ring_size</span>;

    <span class="pl-k">return</span> <span class="pl-s1">strategy</span>;
}</pre></div>
<h3>3.2 大小配置表</h3>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>策略类型</th>
<th>计算公式</th>
<th>默认值 (BLCKSZ=8KB)</th>
<th>上限</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BAS_BULKREAD</strong></td>
<td>256KB / BLCKSZ</td>
<td>32 个缓冲区</td>
<td>NBuffers / 8</td>
</tr>
<tr>
<td><strong>BAS_BULKWRITE</strong></td>
<td>16MB / BLCKSZ</td>
<td>2048 个缓冲区</td>
<td>NBuffers / 8</td>
</tr>
<tr>
<td><strong>BAS_VACUUM</strong></td>
<td>256KB / BLCKSZ</td>
<td>32 个缓冲区</td>
<td>NBuffers / 8</td>
</tr>
<tr>
<td><strong>BAS_NORMAL</strong></td>
<td>N/A</td>
<td>无 Ring (NULL)</td>
<td>N/A</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<blockquote>
<p><strong>注</strong>: 默认的 BLCKSZ 为 8192 字节（8KB）。Ring 大小上限为共享缓冲区总数的 1/8，防止 Ring 占用过多资源。</p>
</blockquote>
<hr>
<h2>4. 工作流程</h2>
<h3>4.1 初始化流程</h3>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/e3ffda3e-347d-48d8-9a09-5dbda8377851"><img width="1200" height="663" alt="Image" src="https://github.com/user-attachments/assets/e3ffda3e-347d-48d8-9a09-5dbda8377851" style="max-width: 100%; height: auto; max-height: 663px;"></a></p>
<h3>4.2 获取 Buffer 流程</h3>
<p><strong>核心函数</strong>: <code class="notranslate">GetBufferFromRing()</code></p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件: src/backend/storage/buffer/freelist.c:610-660 */</span>
<span class="pl-k">static</span> <span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span>
<span class="pl-en">GetBufferFromRing</span>(<span class="pl-smi">BufferAccessStrategy</span> <span class="pl-s1">strategy</span>, <span class="pl-smi">uint32</span> <span class="pl-c1">*</span><span class="pl-s1">buf_state</span>)
{
    <span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span><span class="pl-s1">buf</span>;
    <span class="pl-smi">Buffer</span>      <span class="pl-s1">bufnum</span>;
    <span class="pl-smi">uint32</span>      <span class="pl-s1">local_buf_state</span>;

    <span class="pl-c">/* ========== 关键：环形指针循环推进 ========== */</span>
    <span class="pl-k">if</span> (<span class="pl-c1">++</span><span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span> &gt;= <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ring_size</span>)
        <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;

    <span class="pl-c">/*</span>
<span class="pl-c">     * 如果该槽位尚未填充，告诉调用者使用正常的分配策略分配新缓冲区</span>
<span class="pl-c">     * 调用者随后将通过调用 AddBufferToRing 用新缓冲区填充此槽位</span>
<span class="pl-c">     */</span>
    <span class="pl-s1">bufnum</span> <span class="pl-c1">=</span> <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">buffers</span>[<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span>];
    <span class="pl-k">if</span> (<span class="pl-s1">bufnum</span> <span class="pl-c1">==</span> <span class="pl-s1">InvalidBuffer</span>)
    {
        <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current_was_in_ring</span> <span class="pl-c1">=</span> false;
        <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
    }

    <span class="pl-c">/*</span>
<span class="pl-c">     * 如果缓冲区被 pin 住，则无论如何都不能使用</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * 如果 usage_count 为 0 或 1，则该缓冲区可用</span>
<span class="pl-c">     * （我们期望为 1，因为我们之前对环形元素的使用会留下它，</span>
<span class="pl-c">     * 但此后时钟扫描可能已将其递减）</span>
<span class="pl-c">     * 更高的 usage_count 表示其他人已触摸该缓冲区，因此不应重用</span>
<span class="pl-c">     */</span>
    <span class="pl-s1">buf</span> <span class="pl-c1">=</span> <span class="pl-en">GetBufferDescriptor</span>(<span class="pl-s1">bufnum</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>);
    <span class="pl-s1">local_buf_state</span> <span class="pl-c1">=</span> <span class="pl-en">LockBufHdr</span>(<span class="pl-s1">buf</span>);
    <span class="pl-k">if</span> (<span class="pl-en">BUF_STATE_GET_REFCOUNT</span>(<span class="pl-s1">local_buf_state</span>) <span class="pl-c1">==</span> <span class="pl-c1">0</span>
        <span class="pl-c1">&amp;&amp;</span> <span class="pl-en">BUF_STATE_GET_USAGECOUNT</span>(<span class="pl-s1">local_buf_state</span>) &lt;= <span class="pl-c1">1</span>)
    {
        <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current_was_in_ring</span> <span class="pl-c1">=</span> true;
        <span class="pl-c1">*</span><span class="pl-s1">buf_state</span> <span class="pl-c1">=</span> <span class="pl-s1">local_buf_state</span>;
        <span class="pl-k">return</span> <span class="pl-s1">buf</span>;
    }
    <span class="pl-en">UnlockBufHdr</span>(<span class="pl-s1">buf</span>, <span class="pl-s1">local_buf_state</span>);

    <span class="pl-c">/* 告诉调用者分配新缓冲区，然后通过 AddBufferToRing 替换此环形元素 */</span>
    <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current_was_in_ring</span> <span class="pl-c1">=</span> false;
    <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
}</pre></div>
<p><strong>设计要点</strong>:</p>
<ul>
<li><strong>循环使用</strong>: <code class="notranslate">current</code> 指针循环移动，实现 Ring 的循环复用</li>
<li><strong>可用性检查</strong>: 检查 <code class="notranslate">refcount == 0</code>（未被 pin）和 <code class="notranslate">usage_count &lt;= 1</code>（未被其他人使用）</li>
<li><strong>动态填充</strong>: 初始时 Ring 是空的，由 <code class="notranslate">StrategyGetBuffer()</code> 在获取新 buffer 后填充</li>
</ul>
<p>GetBufferFromRing 中 ring buffer 获取的过程体现了 ring buffer 的环形实现，虽然是个数组，但是里面的 current 是循环推进的：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/ecce4cad-3475-49b9-871e-46ca2bc928b8"><img width="1200" height="750" alt="Image" src="https://github.com/user-attachments/assets/ecce4cad-3475-49b9-871e-46ca2bc928b8" style="max-width: 100%; height: auto; max-height: 750px;"></a></p>
<p>环形槽位状态:</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>状态</th>
<th>buffers[current] 值</th>
<th>含义</th>
<th>处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>未初始化</strong></td>
<td><code class="notranslate">InvalidBuffer</code> (0)</td>
<td>该槽位从未使用过</td>
<td>调用正常分配策略获取新缓冲区</td>
</tr>
<tr>
<td><strong>可用</strong></td>
<td>有效 Buffer 编号</td>
<td>refcount=0 且 usage_count≤1</td>
<td>直接复用该缓冲区</td>
</tr>
<tr>
<td><strong>不可用</strong></td>
<td>有效 Buffer 编号</td>
<td>refcount&gt;0 或 usage_count&gt;1</td>
<td>放弃该缓冲区，获取新缓冲区替换</td>
</tr>
<tr>
<td><strong>脏页拒绝</strong></td>
<td><code class="notranslate">InvalidBuffer</code> (重置)</td>
<td>BULKREAD 模式下遇到脏页</td>
<td>从环形中移除，避免无限循环</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>4.3 添加 Buffer 到 Ring</h3>
<p><strong>核心函数</strong>: <code class="notranslate">AddBufferToRing()</code></p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件: src/backend/storage/buffer/freelist.c:668-672 */</span>
<span class="pl-k">static</span> <span class="pl-smi">void</span>
<span class="pl-en">AddBufferToRing</span>(<span class="pl-smi">BufferAccessStrategy</span> <span class="pl-s1">strategy</span>, <span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span><span class="pl-s1">buf</span>)
{
    <span class="pl-c">/* 非常轻量级：仅将缓冲区编号存入当前槽位 */</span>
    <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">buffers</span>[<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span>] <span class="pl-c1">=</span> <span class="pl-en">BufferDescriptorGetBuffer</span>(<span class="pl-s1">buf</span>);
}</pre></div>
<p>这里是仅将 buffer 编号存入当前槽位。由于调用者已持有 buffer header spinlock，此操作是原子的。</p>
<h3>4.4 StrategyGetBuffer 完整流程</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件: src/backend/storage/buffer/freelist.c:200-358 */</span>

<span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span>
<span class="pl-en">StrategyGetBuffer</span>(<span class="pl-smi">BufferAccessStrategy</span> <span class="pl-s1">strategy</span>, <span class="pl-smi">uint32</span> <span class="pl-c1">*</span><span class="pl-s1">buf_state</span>)
{
	<span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span><span class="pl-s1">buf</span>;
	<span class="pl-smi">int</span>			<span class="pl-s1">bgwprocno</span>;
	<span class="pl-smi">int</span>			<span class="pl-s1">trycounter</span>;
	<span class="pl-smi">uint32</span>		<span class="pl-s1">local_buf_state</span>;

	<span class="pl-c">/*</span>
<span class="pl-c">	 * If given a strategy object, see whether it can select a buffer. We</span>
<span class="pl-c">	 * assume strategy objects don't need buffer_strategy_lock.</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">strategy</span> <span class="pl-c1">!=</span> <span class="pl-c1">NULL</span>)
	{
		<span class="pl-s1">buf</span> <span class="pl-c1">=</span> <span class="pl-en">GetBufferFromRing</span>(<span class="pl-s1">strategy</span>, <span class="pl-s1">buf_state</span>);
		<span class="pl-k">if</span> (<span class="pl-s1">buf</span> <span class="pl-c1">!=</span> <span class="pl-c1">NULL</span>)
			<span class="pl-k">return</span> <span class="pl-s1">buf</span>;
	}

	<span class="pl-c">/* ... bgwriter 通知逻辑 ... */</span>

	<span class="pl-c">/*</span>
<span class="pl-c">	 * First check, without acquiring the lock, whether there's buffers in the</span>
<span class="pl-c">	 * freelist. ...</span>
<span class="pl-c">	 */</span>
	<span class="pl-k">if</span> (<span class="pl-s1">StrategyControl</span><span class="pl-c1">-&gt;</span><span class="pl-c1">firstFreeBuffer</span> &gt;= <span class="pl-c1">0</span>)
	{
		<span class="pl-c">/* ... 从 freelist 获取 buffer ... */</span>
	}

	<span class="pl-c">/* Nothing on the freelist, so run the "clock sweep" algorithm */</span>
	<span class="pl-s1">trycounter</span> <span class="pl-c1">=</span> <span class="pl-s1">NBuffers</span>;
	<span class="pl-k">for</span> (;;)
	{
		<span class="pl-s1">buf</span> <span class="pl-c1">=</span> <span class="pl-en">GetBufferDescriptor</span>(<span class="pl-en">ClockSweepTick</span>());

		<span class="pl-c">/*</span>
<span class="pl-c">		 * If the buffer is pinned or has a nonzero usage_count, we cannot use</span>
<span class="pl-c">		 * it; decrement the usage_count (unless pinned) and keep scanning.</span>
<span class="pl-c">		 */</span>
		<span class="pl-s1">local_buf_state</span> <span class="pl-c1">=</span> <span class="pl-en">LockBufHdr</span>(<span class="pl-s1">buf</span>);

		<span class="pl-k">if</span> (<span class="pl-en">BUF_STATE_GET_REFCOUNT</span>(<span class="pl-s1">local_buf_state</span>) <span class="pl-c1">==</span> <span class="pl-c1">0</span>)
		{
			<span class="pl-k">if</span> (<span class="pl-en">BUF_STATE_GET_USAGECOUNT</span>(<span class="pl-s1">local_buf_state</span>) <span class="pl-c1">!=</span> <span class="pl-c1">0</span>)
			{
				<span class="pl-s1">local_buf_state</span> <span class="pl-c1">-=</span> <span class="pl-c1">BUF_USAGECOUNT_ONE</span>;
				<span class="pl-s1">trycounter</span> <span class="pl-c1">=</span> <span class="pl-s1">NBuffers</span>;
			}
			<span class="pl-k">else</span>
			{
				<span class="pl-c">/* Found a usable buffer */</span>
				<span class="pl-k">if</span> (<span class="pl-s1">strategy</span> <span class="pl-c1">!=</span> <span class="pl-c1">NULL</span>)
					<span class="pl-en">AddBufferToRing</span>(<span class="pl-s1">strategy</span>, <span class="pl-s1">buf</span>);
				<span class="pl-c1">*</span><span class="pl-s1">buf_state</span> <span class="pl-c1">=</span> <span class="pl-s1">local_buf_state</span>;
				<span class="pl-k">return</span> <span class="pl-s1">buf</span>;
			}
		}
		<span class="pl-c">// ...</span>
		<span class="pl-en">UnlockBufHdr</span>(<span class="pl-s1">buf</span>, <span class="pl-s1">local_buf_state</span>);
	}
}</pre></div>
<p><strong>流程说明</strong>:</p>
<ol>
<li>如果提供了 strategy，首先尝试从 Ring 获取 buffer</li>
<li>如果 Ring 无法提供，检查全局 freelist</li>
<li>如果 freelist 为空，使用 Clock Sweep 算法</li>
<li>获取到新 buffer 后，如果使用 strategy，则调用 <code class="notranslate">AddBufferToRing()</code></li>
</ol>
<p><strong>完整流程图</strong>:</p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">flowchart</span> <span class="pl-c1">TD</span>
    <span class="pl-ent">A</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">([</span></span>开始: 需要缓冲区<span class="pl-pds"><span class="pl-sg">])</span></span></span> <span class="pl-k">--&gt;</span> <span class="pl-ent">B</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span>使用 Ring&lt;<span class="pl-ent">br</span>/&gt;策略?<span class="pl-pds"><span class="pl-sg">}</span></span></span>
    <span class="pl-ent">B</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">否</span><span class="pl-k">|</span> <span class="pl-ent">C</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>直接从共享&lt;<span class="pl-ent">br</span>/&gt;缓冲池分配<span class="pl-pds"><span class="pl-sg">]</span></span></span>
    <span class="pl-ent">B</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">是</span><span class="pl-k">|</span> <span class="pl-ent">D</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>GetBufferFromRing<span class="pl-pds"><span class="pl-sg">]</span></span></span>

    <span class="pl-ent">D</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">E</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span>ring 中有&lt;<span class="pl-ent">br</span>/&gt;可用?<span class="pl-pds"><span class="pl-sg">}</span></span></span>
    <span class="pl-ent">E</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">有</span><span class="pl-k">|</span> <span class="pl-ent">F</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>复用 ring 中的&lt;<span class="pl-ent">br</span>/&gt;共享缓冲区<span class="pl-pds"><span class="pl-sg">]</span></span></span>
    <span class="pl-ent">E</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">无</span><span class="pl-k">|</span> <span class="pl-ent">G</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>从共享缓冲池&lt;<span class="pl-ent">br</span>/&gt;分配新缓冲区<span class="pl-pds"><span class="pl-sg">]</span></span></span>

    <span class="pl-ent">G</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">H</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span>从 freelist&lt;<span class="pl-ent">br</span>/&gt;获取?<span class="pl-pds"><span class="pl-sg">}</span></span></span>
    <span class="pl-ent">H</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">是</span><span class="pl-k">|</span> <span class="pl-ent">I</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>获取空闲缓冲区<span class="pl-pds"><span class="pl-sg">]</span></span></span>
    <span class="pl-ent">H</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">否</span><span class="pl-k">|</span> <span class="pl-ent">J</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>执行 Clock Sweep&lt;<span class="pl-ent">br</span>/&gt;算法<span class="pl-pds"><span class="pl-sg">]</span></span></span>

    <span class="pl-ent">I</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">K</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>AddBufferToRing&lt;<span class="pl-ent">br</span>/&gt;存储 ID 到 ring<span class="pl-pds"><span class="pl-sg">]</span></span></span>
    <span class="pl-ent">J</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">K</span>

    <span class="pl-ent">K</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">L</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">([</span></span>返回共享缓冲区指针<span class="pl-pds"><span class="pl-sg">])</span></span></span>
    <span class="pl-ent">F</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">L</span>
    <span class="pl-ent">C</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">L</span>

    <span class="pl-k">style</span> <span class="pl-ent">A</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#e3f2fd</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#1976d2</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">B</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#fff9c4</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#f57f17</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">C</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#e8f5e9</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#388e3c</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">D</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#e8f5e9</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#388e3c</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">E</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#fff9c4</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#f57f17</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">F</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#c8e6c9</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#388e3c</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">G</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#e8f5e9</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#388e3c</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">H</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#fff9c4</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#f57f17</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">I</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#e8f5e9</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#388e3c</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">J</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#e8f5e9</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#388e3c</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">K</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#fff9c4</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#f57f17</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">style</span> <span class="pl-ent">L</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#e3f2fd</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#1976d2</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>

    <span class="pl-k">linkStyle</span> <span class="pl-c1">default</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#4a5568</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span></pre></div>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">flowchart</span> <span class="pl-c1">TD</span>
    <span class="pl-k">subgraph</span> <span class="pl-en">RingBuffer</span>
        <span class="pl-k">direction</span> <span class="pl-c1">TB</span>

        <span class="pl-k">subgraph</span> <span class="pl-en">Init</span>
            <span class="pl-ent">A1</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>GetAccessStrategy&lt;<span class="pl-ent">br</span>/&gt;根据类型设置 ring_size<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span> <span class="pl-k">--&gt;</span> <span class="pl-ent">A2</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>分配 buffers[ring_size] 数组&lt;<span class="pl-ent">br</span>/&gt;所有元素初始化为 InvalidBuffer<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
        <span class="pl-k">end</span>

        <span class="pl-k">subgraph</span> <span class="pl-en">GetBuffer</span>
            <span class="pl-ent">B1</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>GetBufferFromRing<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span> <span class="pl-k">--&gt;</span> <span class="pl-ent">B2</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span><span class="pl-s"><span class="pl-pds">"</span>current 指针循环推进&lt;<span class="pl-ent">br</span>/&gt;if ++current &gt;= ring_size&lt;<span class="pl-ent">br</span>/&gt;current = 0<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">}</span></span></span>
            <span class="pl-ent">B2</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">B3</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span><span class="pl-s"><span class="pl-pds">"</span>buffers[current] == InvalidBuffer?<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">}</span></span></span>
            <span class="pl-ent">B3</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">Yes</span><span class="pl-k">|</span> <span class="pl-ent">B4</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>返回 NULL&lt;<span class="pl-ent">br</span>/&gt;需要分配新缓冲区<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
            <span class="pl-ent">B3</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">No</span><span class="pl-k">|</span> <span class="pl-ent">B5</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span><span class="pl-s"><span class="pl-pds">"</span>refcount==0 &amp;&amp;&lt;<span class="pl-ent">br</span>/&gt;usage_count&lt;=1?<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">}</span></span></span>
            <span class="pl-ent">B5</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">Yes</span><span class="pl-k">|</span> <span class="pl-ent">B6</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>返回该缓冲区&lt;<span class="pl-ent">br</span>/&gt;current_was_in_ring=true<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
            <span class="pl-ent">B5</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">No</span><span class="pl-k">|</span> <span class="pl-ent">B4</span>
        <span class="pl-k">end</span>

        <span class="pl-k">subgraph</span> <span class="pl-en">Allocate</span>
            <span class="pl-ent">C1</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>StrategyGetBuffer<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span> <span class="pl-k">--&gt;</span> <span class="pl-ent">C2</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span><span class="pl-s"><span class="pl-pds">"</span>有可用缓冲区?<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">}</span></span></span>
            <span class="pl-ent">C2</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">No</span><span class="pl-k">|</span> <span class="pl-ent">C3</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>调用正常时钟扫描&lt;<span class="pl-ent">br</span>/&gt;ClockSweepTick 获取 victim<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
            <span class="pl-ent">C3</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">C4</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>AddBufferToRing&lt;<span class="pl-ent">br</span>/&gt;buffers[current] = new_buffer<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
        <span class="pl-k">end</span>

        <span class="pl-k">subgraph</span> <span class="pl-en">Reject</span>
            <span class="pl-ent">D1</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>需要写脏缓冲区?<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span> <span class="pl-k">--&gt;</span> <span class="pl-ent">D2</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">{</span></span><span class="pl-s"><span class="pl-pds">"</span>btype == BAS_BULKREAD &amp;&amp;&lt;<span class="pl-ent">br</span>/&gt;current_was_in_ring?<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">}</span></span></span>
            <span class="pl-ent">D2</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">Yes</span><span class="pl-k">|</span> <span class="pl-ent">D3</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>StrategyRejectBuffer&lt;<span class="pl-ent">br</span>/&gt;buffers[current] = InvalidBuffer&lt;<span class="pl-ent">br</span>/&gt;返回 true 要求重新分配<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
            <span class="pl-ent">D2</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">No</span><span class="pl-k">|</span> <span class="pl-ent">D4</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>继续正常写入<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    <span class="pl-ent">Init</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">GetBuffer</span>
    <span class="pl-ent">GetBuffer</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">返回 NULL</span><span class="pl-k">|</span> <span class="pl-ent">Allocate</span>
    <span class="pl-ent">Allocate</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">GetBuffer</span>
    <span class="pl-ent">GetBuffer</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">需要写脏页</span><span class="pl-k">|</span> <span class="pl-ent">Reject</span>
    <span class="pl-ent">Reject</span> <span class="pl-k">--&gt;</span><span class="pl-k">|</span><span class="pl-s">重新分配</span><span class="pl-k">|</span> <span class="pl-ent">Allocate</span></pre></div>
<hr>
<h2>5. 使用场景</h2>
<h3>5.1 大表扫描 (BAS_BULKREAD)</h3>
<p><strong>适用场景</strong>:</p>
<ul>
<li>大型只读扫描，如顺序扫描大表</li>
<li>读取的页面可能只访问一次</li>
</ul>
<p><strong>设计考量</strong>：</p>
<ul>
<li>使用 <code class="notranslate">BAS_BULKREAD</code> 策略</li>
<li>环大小：256KB（约 32 个 8KB 页面）</li>
<li>允许提示位（hint bits）更新</li>
<li><strong>特殊处理</strong>：通过 <code class="notranslate">StrategyRejectBuffer()</code> 拒绝需要 WAL 刷新的脏缓冲区</li>
<li>脏页会被移除以避免无限循环</li>
</ul>
<p><strong>代码示例</strong>:</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件：src/backend/access/heap/heapam.c:254-280 */</span>
<span class="pl-c">/*</span>
<span class="pl-c">     * If the table is large relative to NBuffers, use a bulk-read access</span>
<span class="pl-c">     * strategy and enable synchronized scanning (see syncscan.c).  Although</span>
<span class="pl-c">     * the thresholds for these features could be different, we make them the</span>
<span class="pl-c">     * same so that there are only two behaviors to tune rather than four.</span>
<span class="pl-c">     * (However, some callers need to be able to disable one or both of these</span>
<span class="pl-c">     * behaviors, independently of the size of the table; also there is a GUC</span>
<span class="pl-c">     * variable that can disable synchronized scanning.)</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * Note that table_block_parallelscan_initialize has a very similar test;</span>
<span class="pl-c">     * if you change this, consider changing that one, too.</span>
<span class="pl-c">     */</span>
    <span class="pl-k">if</span> (!<span class="pl-en">RelationUsesLocalBuffers</span>(<span class="pl-s1">scan</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rs_base</span>.<span class="pl-c1">rs_rd</span>) <span class="pl-c1">&amp;&amp;</span>
        <span class="pl-s1">scan</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rs_nblocks</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">NBuffers</span> / <span class="pl-c1">4</span>)
    {
        <span class="pl-s1">allow_strat</span> <span class="pl-c1">=</span> (<span class="pl-s1">scan</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rs_base</span>.<span class="pl-c1">rs_flags</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">SO_ALLOW_STRAT</span>) <span class="pl-c1">!=</span> <span class="pl-c1">0</span>;
        <span class="pl-s1">allow_sync</span> <span class="pl-c1">=</span> (<span class="pl-s1">scan</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rs_base</span>.<span class="pl-c1">rs_flags</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">SO_ALLOW_SYNC</span>) <span class="pl-c1">!=</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">else</span>
        <span class="pl-s1">allow_strat</span> <span class="pl-c1">=</span> <span class="pl-s1">allow_sync</span> <span class="pl-c1">=</span> false;
    <span class="pl-k">if</span> (<span class="pl-s1">allow_strat</span>)
    {
        <span class="pl-c">/* During a rescan, keep the previous strategy object. */</span>
        <span class="pl-k">if</span> (<span class="pl-s1">scan</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rs_strategy</span> <span class="pl-c1">==</span> <span class="pl-c1">NULL</span>)
            <span class="pl-s1">scan</span><span class="pl-c1">-&gt;</span><span class="pl-c1">rs_strategy</span> <span class="pl-c1">=</span> <span class="pl-en">GetAccessStrategy</span>(<span class="pl-c1">BAS_BULKREAD</span>);
    }</pre></div>
<p><strong>优势</strong>:</p>
<ol>
<li><strong>避免污染缓冲池</strong>: 大表扫描只使用 Ring 内的缓冲区，不会频繁逐出全局缓冲池中的热数据</li>
<li><strong>快速回收</strong>: Ring 内的缓冲区可以快速回收复用</li>
<li><strong>可拒绝写脏页</strong>: <code class="notranslate">StrategyRejectBuffer()</code> 允许在需要刷 WAL 时选择其他 victim，避免等待</li>
</ol>
<p><strong>拒绝脏缓冲区逻辑</strong>：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">bool</span>
<span class="pl-en">StrategyRejectBuffer</span>(<span class="pl-smi">BufferAccessStrategy</span> <span class="pl-s1">strategy</span>, <span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span><span class="pl-s1">buf</span>)
{
    <span class="pl-c">/* 仅在 bulkread 模式下执行 */</span>
    <span class="pl-k">if</span> (<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">btype</span> <span class="pl-c1">!=</span> <span class="pl-c1">BAS_BULKREAD</span>)
        <span class="pl-k">return</span> false;

    <span class="pl-c">/* 不干扰正常缓冲区替换策略的行为 */</span>
    <span class="pl-k">if</span> (!<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current_was_in_ring</span> <span class="pl-c1">||</span>
        <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">buffers</span>[<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span>] <span class="pl-c1">!=</span> <span class="pl-en">BufferDescriptorGetBuffer</span>(<span class="pl-s1">buf</span>))
        <span class="pl-k">return</span> false;

    <span class="pl-c">/* 从环中移除脏缓冲区，防止所有环成员都为脏时无限循环 */</span>
    <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">buffers</span>[<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span>] <span class="pl-c1">=</span> <span class="pl-s1">InvalidBuffer</span>;

    <span class="pl-k">return</span> true;
}</pre></div>
<p><strong>作用</strong>:</p>
<ul>
<li><strong>仅用于 BAS_BULKREAD</strong>: 批量写入不需要此功能，因为写入操作本身就是产生脏页的</li>
<li><strong>避免 WAL 等待</strong>: 当需要写脏页且需要刷 WAL 时，可以选择拒绝这个 buffer，让 BufferAlloc 选择其他 victim</li>
<li><strong>防止死循环</strong>: 如果 Ring 中所有 buffer 都是脏的且都需要刷 WAL，不拒绝会导致死循环</li>
</ul>
<h3>5.2 批量写入 (BAS_BULKWRITE)</h3>
<p><strong>适用场景</strong>:</p>
<ul>
<li>大型多块写入操作，如 <code class="notranslate">COPY IN</code>、<code class="notranslate">CREATE TABLE AS SELECT</code></li>
</ul>
<p><strong>设计考量</strong>:</p>
<ul>
<li>使用 <code class="notranslate">BAS_BULKWRITE</code> 策略</li>
<li><strong>更大的 Ring</strong>: 16MB 默认大小（2048 个缓冲区），允许更多脏页累积</li>
<li><strong>更好的顺序写</strong>: 大批量数据可以集中刷盘，减少随机 I/O</li>
<li><strong>减少 WAL 压力</strong>: 批量操作可以更有效地组织 WAL 写入</li>
</ul>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* heapam.c */</span>
<span class="pl-c">/* ... */</span>
<span class="pl-s1">bistate</span><span class="pl-c1">-&gt;</span><span class="pl-c1">strategy</span> <span class="pl-c1">=</span> <span class="pl-en">GetAccessStrategy</span>(<span class="pl-c1">BAS_BULKWRITE</span>);
<span class="pl-c">/* ... */</span></pre></div>
<h3>5.3 VACUUM (BAS_VACUUM)</h3>
<p><strong>适用场景</strong>:</p>
<ul>
<li>VACUUM 操作</li>
</ul>
<p><strong>设计考量</strong>:</p>
<ul>
<li>使用 <code class="notranslate">BAS_VACUUM</code> 策略</li>
<li>限制在约 256KB 的环内</li>
<li>VACUUM 结束后，这些页面自然被驱逐</li>
<li>不影响全局缓冲池的热点数据</li>
</ul>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* vacuumlazy.c 中的示例 */</span>
<span class="pl-s1">vacrel</span>.<span class="pl-c1">bstrategy</span> <span class="pl-c1">=</span> <span class="pl-en">GetAccessStrategy</span>(<span class="pl-c1">BAS_VACUUM</span>);

<span class="pl-c">/* 执行 VACUUM 扫描 */</span>
<span class="pl-c">/* ... */</span>

<span class="pl-en">FreeAccessStrategy</span>(<span class="pl-s1">vacrel</span>.<span class="pl-c1">bstrategy</span>);</pre></div>
<h3>5.4 BAS_NORMAL（正常访问）</h3>
<p><strong>特点</strong>：</p>
<ul>
<li>返回 <code class="notranslate">NULL</code>，使用默认的 Clock Sweep 算法</li>
<li>不使用 Ring Buffer</li>
</ul>
<hr>
<h2>6. Ring Buffer 与共享 Buffer 的关系</h2>
<h3>6.1 两者关系</h3>
<p>Ring Buffer 涉及两个层面的概念：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>层面</th>
<th>内容</th>
<th>位置</th>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>结构层面</strong></td>
<td><code class="notranslate">BufferAccessStrategy</code> 结构体及其 <code class="notranslate">buffers[]</code> 数组</td>
<td>后端进程私有内存</td>
<td><strong>私有</strong></td>
</tr>
<tr>
<td><strong>存储层面</strong></td>
<td><code class="notranslate">buffers[]</code> 中 ID 指向的实际缓冲区（数据页）</td>
<td>共享内存（Shared Buffers）</td>
<td><strong>共享</strong></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p><strong>Ring Buffer 的"私有"指的是分配策略的私有，而不是缓冲区物理存储的私有。</strong></p>
<ul>
<li><strong>私有部分</strong>：每个后端进程有自己的 <code class="notranslate">BufferAccessStrategy</code> 结构体，记录它的缓冲区 ID 列表</li>
<li><strong>共享部分</strong>：这些 ID 指向的缓冲区物理上仍然在全局共享缓冲池中</li>
</ul>
<h3>6.2 架构关系图</h3>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">flowchart</span> <span class="pl-c1">LR</span>
    <span class="pl-k">subgraph</span> <span class="pl-en">BP</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>"后端私有内存"<span class="pl-pds"><span class="pl-sg">]</span></span></span>
        <span class="pl-k">direction</span> <span class="pl-c1">TB</span>
        <span class="pl-ent">BAS</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>BufferAccessStrategy&lt;<span class="pl-ent">br</span>/&gt;结构体<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
        <span class="pl-ent">ARR</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>buffers[] 数组&lt;<span class="pl-ent">br</span>/&gt;ring_size 个 Buffer ID<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
        <span class="pl-ent">BAS</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">ARR</span>
    <span class="pl-k">end</span>

    <span class="pl-k">subgraph</span> <span class="pl-en">SM</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>"共享内存"<span class="pl-pds"><span class="pl-sg">]</span></span></span>
        <span class="pl-k">direction</span> <span class="pl-c1">TB</span>
        <span class="pl-ent">SBP</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>全局缓冲池&lt;<span class="pl-ent">br</span>/&gt;Shared Buffers<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>

        <span class="pl-k">subgraph</span> <span class="pl-en">BUF</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span>"缓冲区数组"<span class="pl-pds"><span class="pl-sg">]</span></span></span>
            <span class="pl-ent">BUF1</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>Buffer 0&lt;<span class="pl-ent">br</span>/&gt;BufferDescriptor<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
            <span class="pl-ent">BUF2</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>Buffer 1&lt;<span class="pl-ent">br</span>/&gt;BufferDescriptor<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
            <span class="pl-ent">BUF3</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>Buffer 2&lt;<span class="pl-ent">br</span>/&gt;BufferDescriptor<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
            <span class="pl-ent">BUFN</span><span class="pl-s"><span class="pl-pds"><span class="pl-sg">[</span></span><span class="pl-s"><span class="pl-pds">"</span>Buffer N-1&lt;<span class="pl-ent">br</span>/&gt;BufferDescriptor<span class="pl-pds">"</span></span><span class="pl-pds"><span class="pl-sg">]</span></span></span>
        <span class="pl-k">end</span>

        <span class="pl-ent">SBP</span> <span class="pl-k">--&gt;</span> <span class="pl-ent">BUF</span>
    <span class="pl-k">end</span>

    <span class="pl-ent">ARR</span> <span class="pl-k">-.-&gt;</span><span class="pl-k">|</span><span class="pl-s">"ID = 1"</span><span class="pl-k">|</span> <span class="pl-ent">BUF1</span>
    <span class="pl-ent">ARR</span> <span class="pl-k">-.-&gt;</span><span class="pl-k">|</span><span class="pl-s">"ID = 5"</span><span class="pl-k">|</span> <span class="pl-ent">BUF2</span>
    <span class="pl-ent">ARR</span> <span class="pl-k">-.-&gt;</span><span class="pl-k">|</span><span class="pl-s">"ID = 12"</span><span class="pl-k">|</span> <span class="pl-ent">BUF3</span>

    <span class="pl-k">classDef</span> <span class="pl-en">privateNode</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#fff9c4</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#f57f17</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">classDef</span> <span class="pl-en">sharedNode</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#f3e5f5</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#7b1fa2</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>
    <span class="pl-k">classDef</span> <span class="pl-en">bufferNode</span> <span class="pl-s1"><span class="pl-c1"><span class="pl-c1">fill</span></span>:<span class="pl-c1">#e8f5e9</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke</span></span>:<span class="pl-c1">#388e3c</span></span><span class="pl-sg">,</span><span class="pl-s1"><span class="pl-c1"><span class="pl-c1">stroke-width</span></span>:<span class="pl-c1">2<span class="pl-k">px</span></span></span>

    <span class="pl-k">class</span> <span class="pl-ent">BAS</span>,<span class="pl-ent">ARR</span> <span class="pl-en">privateNode</span>
    <span class="pl-k">class</span> <span class="pl-ent">SBP</span> <span class="pl-en">sharedNode</span>
    <span class="pl-k">class</span> <span class="pl-ent">BUF1</span>,<span class="pl-ent">BUF2</span>,<span class="pl-ent">BUF3</span>,<span class="pl-ent">BUFN</span> <span class="pl-en">bufferNode</span></pre></div>
<h3>6.3 组件关系图</h3>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>组件</th>
<th>位置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">BufferAccessStrategy</code> 结构体</td>
<td>后端私有内存</td>
<td>使用 <code class="notranslate">palloc()</code> 分配</td>
</tr>
<tr>
<td><code class="notranslate">buffers[]</code> 数组</td>
<td>后端私有内存</td>
<td>存储 Buffer ID（整数）</td>
</tr>
<tr>
<td><code class="notranslate">BufferDescriptor</code></td>
<td>共享内存</td>
<td>缓冲区描述符</td>
</tr>
<tr>
<td>数据页（8KB）</td>
<td>共享内存</td>
<td>实际存储的数据</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>6.4 内存布局详解</h3>
<pre class="notranslate"><code class="notranslate">┌─────────────────────────────────────────────────────┐
│              后端进程内存空间                          │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ┌─────────────────────────────────────────────┐   │
│  │  BufferAccessStrategy 结构体                 │   │  ← 私有
│  │  ┌─────────────────────────────────────┐    │   │
│  │  │ btype: BAS_BULKREAD                 │    │   │
│  │  │ ring_size: 32                       │    │   │
│  │  │ current: 5                          │    │   │
│  │  │ current_was_in_ring: true           │    │   │
│  │  │                                     │    │   │
│  │  │ buffers[] 数组:                     │    │   │
│  │  │  [0] = 125   ←────┐                │    │   │
│  │  │  [1] = 0         │                │    │   │
│  │  │  [2] = 347   ←───┼────────┐       │    │   │
│  │  │  [3] = 891   ←───┼───┐    │       │    │   │
│  │  │  ...             │   │    │       │    │   │
│  │  │  [31] = 12   ←───┘   │    │       │    │   │
│  │  └─────────────────────┼────┴────────┘   │    │
│  └────────────────────────│─────────────────┘    │
│                           │                       │
│                           │ 存储的是 ID            │
│                           ↓                       │
└───────────────────────────┼───────────────────────┘
                            │ 只存整数 ID
                            │
                            │
┌───────────────────────────┼───────────────────────┐
│  共享内存                  │                       |
│                           │                       │
│  ┌────────────────────────┼─────────────────────┐ │
│  │  BufferDescriptors[]   │                     │ │
│  │  ┌─────────────────────────────────────┐     │ │
│  │  │ [0]  →  数据页 0                     │     │ │
│  │  │ [1]  →  数据页 1                     │     │ │
│  │  │ ...                                 │     │ │
│  │  │ [12] ───────┐                       │     │ │  ← 实际数据
│  │  │ [13]        │                       │     │ │     在这里
│  │  │ ...         │                       │     │ │
│  │  │ [125] ──────┼───┐                   │     │ │
│  │  │ [126]       │   │                   │     │ │
│  │  │ ...         │   │                   │     │ │
│  │  │ [347] ──────┼───┼───┐               │     │ │
│  │  │ [348]       │   │   │               │     │ │
│  │  │ ...         │   │   │               │     │ │
│  │  │ [891] ──────┴───┴───┘               │     │ │
│  │  └─────────────────────────────────────┘     │ │
│  └─────────────────────────────────────────────┘  │
│                                                   │
└───────────────────────────────────────────────────┘
</code></pre>
<h3>6.5 Ring Buffer 创建（私有内存分配）</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件：backend/storage/buffer/freelist.c:159-161 */</span>
<span class="pl-s1">strategy</span> <span class="pl-c1">=</span> (<span class="pl-smi">BufferAccessStrategy</span>)
    <span class="pl-en">palloc0</span>(offsetof(<span class="pl-smi">BufferAccessStrategyData</span>, <span class="pl-c1">buffers</span>) <span class="pl-c1">+</span>
            <span class="pl-s1">ring_size</span> <span class="pl-c1">*</span> <span class="pl-k">sizeof</span>(<span class="pl-s1">Buffer</span>));</pre></div>
<p><strong>关键点</strong>：</p>
<ul>
<li>使用 <code class="notranslate">palloc()</code> 而非 <code class="notranslate">ShmemAlloc()</code></li>
<li><code class="notranslate">palloc()</code> 在<strong>当前内存上下文</strong>（后端进程私有）中分配</li>
<li>只分配存储 ID 的数组，不分配实际缓冲区</li>
</ul>
<h3>6.6 添加缓冲区到 Ring（只存 ID）</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件：backend/storage/buffer/freelist.c:305-309 */</span>
<span class="pl-k">static</span> <span class="pl-smi">void</span>
<span class="pl-en">AddBufferToRing</span>(<span class="pl-smi">BufferAccessStrategy</span> <span class="pl-s1">strategy</span>, <span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span><span class="pl-s1">buf</span>)
{
    <span class="pl-c">/*</span>
<span class="pl-c">     * 注意：这里只存储 Buffer ID，不是复制缓冲区内容</span>
<span class="pl-c">     * BufferDescriptor 仍然在共享内存中</span>
<span class="pl-c">     */</span>
    <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">buffers</span>[<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span>] <span class="pl-c1">=</span>
        <span class="pl-en">BufferDescriptorGetBuffer</span>(<span class="pl-s1">buf</span>);
}</pre></div>
<p><strong><code class="notranslate">BufferDescriptorGetBuffer</code> 宏定义</strong>：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">// include/storage/buf_internals.h</span>
<span class="pl-k">#define</span> <span class="pl-en">BufferDescriptorGetBuffer</span>(<span class="pl-s1">bdesc</span>) \
    ((bdesc)-&gt;buf_id + 1)  // 只返回 buf_id + 1，是一个整数</pre></div>
<h3>6.7 从 Ring 获取缓冲区（ID 转指针）</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件：backend/storage/buffer/freelist.c:259-267 */</span>
<span class="pl-k">static</span> <span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span>
<span class="pl-en">GetBufferFromRing</span>(<span class="pl-smi">BufferAccessStrategy</span> <span class="pl-s1">strategy</span>, <span class="pl-smi">uint32</span> <span class="pl-c1">*</span><span class="pl-s1">buf_state</span>)
{
    <span class="pl-smi">Buffer</span>      <span class="pl-s1">bufnum</span>;

    <span class="pl-c">/* 前进到下一个 ring 槽位 */</span>
    <span class="pl-k">if</span> (<span class="pl-c1">++</span><span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span> &gt;= <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">ring_size</span>)
        <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;

    <span class="pl-c">/* 获取存储的 Buffer ID */</span>
    <span class="pl-s1">bufnum</span> <span class="pl-c1">=</span> <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">buffers</span>[<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span>];
    <span class="pl-k">if</span> (<span class="pl-s1">bufnum</span> <span class="pl-c1">==</span> <span class="pl-s1">InvalidBuffer</span>)
        <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;  <span class="pl-c">// 槽位未填充</span>

    <span class="pl-c">/*</span>
<span class="pl-c">     * 通过 ID 获取共享内存中的 BufferDescriptor</span>
<span class="pl-c">     * 这一步是从共享内存访问！</span>
<span class="pl-c">     */</span>
    <span class="pl-s1">buf</span> <span class="pl-c1">=</span> <span class="pl-en">GetBufferDescriptor</span>(<span class="pl-s1">bufnum</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>);

    <span class="pl-c">/* 检查缓冲区状态（需要访问共享内存中的原子变量） */</span>
    <span class="pl-s1">local_buf_state</span> <span class="pl-c1">=</span> <span class="pl-en">LockBufHdr</span>(<span class="pl-s1">buf</span>);
    <span class="pl-k">if</span> (<span class="pl-en">BUF_STATE_GET_REFCOUNT</span>(<span class="pl-s1">local_buf_state</span>) <span class="pl-c1">==</span> <span class="pl-c1">0</span>
        <span class="pl-c1">&amp;&amp;</span> <span class="pl-en">BUF_STATE_GET_USAGECOUNT</span>(<span class="pl-s1">local_buf_state</span>) &lt;= <span class="pl-c1">1</span>)
    {
        <span class="pl-c">/* 可以使用这个共享缓冲区 */</span>
        <span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current_was_in_ring</span> <span class="pl-c1">=</span> true;
        <span class="pl-c1">*</span><span class="pl-s1">buf_state</span> <span class="pl-c1">=</span> <span class="pl-s1">local_buf_state</span>;
        <span class="pl-k">return</span> <span class="pl-s1">buf</span>;  <span class="pl-c">// 返回共享内存中的指针</span>
    }
    <span class="pl-en">UnlockBufHdr</span>(<span class="pl-s1">buf</span>, <span class="pl-s1">local_buf_state</span>);

    <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
}</pre></div>
<p><strong><code class="notranslate">GetBufferDescriptor</code> 实现</strong>：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">// backend/storage/buffer/bufmgr.c</span>
<span class="pl-k">#define</span> <span class="pl-en">GetBufferDescriptor</span>(<span class="pl-s1">id</span>) \
    (&amp;BufferDescriptors[(id)])  // 直接访问共享内存中的数组</pre></div>
<h3>6.8 为什么是"准私有"？</h3>
<p><strong>复用条件检查</strong>：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件：srcc/backend/storage/buffer/freelist.c:261-262 */</span>
<span class="pl-k">if</span> (<span class="pl-en">BUF_STATE_GET_REFCOUNT</span>(<span class="pl-s1">local_buf_state</span>) <span class="pl-c1">==</span> <span class="pl-c1">0</span>
    <span class="pl-c1">&amp;&amp;</span> <span class="pl-en">BUF_STATE_GET_USAGECOUNT</span>(<span class="pl-s1">local_buf_state</span>) &lt;= <span class="pl-c1">1</span>)</pre></div>
<p><strong>解释</strong>：</p>
<ol>
<li><strong><code class="notranslate">refcount == 0</code></strong>：缓冲区未被任何进程 pin</li>
<li><strong><code class="notranslate">usage_count &lt;= 1</code></strong>：
<ul>
<li><code class="notranslate">= 0</code>：缓冲区未被使用</li>
<li><code class="notranslate">= 1</code>：只有当前进程使用过（可复用）</li>
<li><code class="notranslate">&gt; 1</code>：其他进程也使用过（不能复用，避免影响其他进程）</li>
</ul>
</li>
</ol>
<p>即使缓冲区在 ring 中，如果其他进程正在使用，当前进程也不能复用。</p>
<h3>6.9 常见误区</h3>
<h4>6.9.1 误区一："Ring Buffer 是独立的缓冲区"</h4>
<p><strong>错误理解</strong>：</p>
<blockquote>
<p>Ring Buffer 是独立于共享缓存之外或是在进程私有内存中分配的独立缓冲区。</p>
</blockquote>
<p><strong>正确理解</strong>：</p>
<blockquote>
<p>Ring Buffer 只是一个<strong>策略机制</strong>，记录了进程优先使用的共享缓冲区 ID 列表。</p>
</blockquote>
<h4>6.9.2 误区二："Ring Buffer 中的数据是私有的"</h4>
<p><strong>错误理解</strong>：</p>
<blockquote>
<p>Ring Buffer 中存储的数据页是进程私有的，其他进程无法访问。</p>
</blockquote>
<p><strong>正确理解</strong>：</p>
<blockquote>
<p>Ring Buffer 中的 ID 指向的数据页在共享内存中，其他进程可能通过缓冲池访问到相同的页。</p>
</blockquote>
<h4>6.9.3 误区三："使用 Ring Buffer 会复制数据"</h4>
<p><strong>错误理解</strong>：</p>
<blockquote>
<p>添加缓冲区到 Ring 时会复制数据到私有内存。</p>
</blockquote>
<p><strong>正确理解</strong>：</p>
<blockquote>
<p>添加缓冲区到 Ring 时<strong>只复制 ID</strong>，不复制任何数据。</p>
</blockquote>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">// 只存储 ID，没有 memcpy 或类似操作</span>
<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">buffers</span>[<span class="pl-s1">strategy</span><span class="pl-c1">-&gt;</span><span class="pl-c1">current</span>] <span class="pl-c1">=</span> <span class="pl-en">BufferDescriptorGetBuffer</span>(<span class="pl-s1">buf</span>);
<span class="pl-c">// 等价于：strategy-&gt;buffers[strategy-&gt;current] = buf-&gt;buf_id + 1;</span></pre></div>
<h4>6.9.4 误区四："Ring Buffer 完全隔离"</h4>
<p><strong>错误理解</strong>：</p>
<blockquote>
<p>使用 Ring Buffer 的进程完全隔离，不会影响其他进程。</p>
</blockquote>
<p><strong>正确理解</strong>：</p>
<blockquote>
<p>Ring Buffer 只是一种<strong>优先级策略</strong>，不提供完全隔离：</p>
<ul>
<li>其他进程可能访问 ring 中的缓冲区（通过 Clock Sweep）</li>
<li>当前进程可能被拒绝使用 ring 中的脏缓冲区（<code class="notranslate">StrategyRejectBuffer</code>）</li>
</ul>
</blockquote>
<h3>6.10 对比表</h3>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>特性</th>
<th>Ring Buffer</th>
<th>普通 Buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据结构</strong></td>
<td>BufferAccessStrategyData (进程私有)</td>
<td>BufferDesc (共享内存)</td>
</tr>
<tr>
<td><strong>分配策略</strong></td>
<td>循环使用固定集合</td>
<td>Clock Sweep 全局选择</td>
</tr>
<tr>
<td><strong>usage_count</strong></td>
<td>最高为 1 (PinBuffer 中限制)</td>
<td>可达 BM_MAX_USAGE_COUNT (5)</td>
</tr>
<tr>
<td><strong>替换范围</strong></td>
<td>限于 ring 内</td>
<td>整个缓冲池 (NBuffers)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>大表扫描、批量操作、VACUUM</td>
<td>随机访问、OLTP 查询</td>
</tr>
<tr>
<td><strong>污染性</strong></td>
<td>低 (Ring 大小受限)</td>
<td>高 (可能逐出热数据)</td>
</tr>
<tr>
<td><strong>锁竞争</strong></td>
<td>无 (进程私有)</td>
<td>需要 buffer_strategy_lock</td>
</tr>
<tr>
<td><strong>内存位置</strong></td>
<td>进程私有内存 (palloc)</td>
<td>共享内存 (ShmemInitStruct)</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>6.11 Ring Buffer 中的 usage_count 处理</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* 源文件: src/backend/storage/buffer/bufmgr.c:1691-1771 */</span>
<span class="pl-k">static</span> <span class="pl-smi">bool</span>
<span class="pl-en">PinBuffer</span>(<span class="pl-smi">BufferDesc</span> <span class="pl-c1">*</span><span class="pl-s1">buf</span>, <span class="pl-smi">BufferAccessStrategy</span> <span class="pl-s1">strategy</span>)
{
    <span class="pl-c">// ...</span>
    <span class="pl-k">if</span> (<span class="pl-s1">strategy</span> <span class="pl-c1">==</span> <span class="pl-c1">NULL</span>)
    {
        <span class="pl-c">/* Default case: increase usagecount unless already max. */</span>
        <span class="pl-k">if</span> (<span class="pl-en">BUF_STATE_GET_USAGECOUNT</span>(<span class="pl-s1">buf_state</span>) <span class="pl-c1">&lt;</span> <span class="pl-c1">BM_MAX_USAGE_COUNT</span>)
            <span class="pl-s1">buf_state</span> <span class="pl-c1">+=</span> <span class="pl-c1">BUF_USAGECOUNT_ONE</span>;
    }
    <span class="pl-k">else</span>
    {
        <span class="pl-c">/*</span>
<span class="pl-c">         * Ring buffers shouldn't evict others from pool.  Thus we</span>
<span class="pl-c">         * don't make usagecount more than 1.</span>
<span class="pl-c">         */</span>
        <span class="pl-k">if</span> (<span class="pl-en">BUF_STATE_GET_USAGECOUNT</span>(<span class="pl-s1">buf_state</span>) <span class="pl-c1">==</span> <span class="pl-c1">0</span>)
            <span class="pl-s1">buf_state</span> <span class="pl-c1">+=</span> <span class="pl-c1">BUF_USAGECOUNT_ONE</span>;
    }
    <span class="pl-c">// ...</span>
}</pre></div>
<p><strong>关键区别</strong>:</p>
<ul>
<li><strong>普通 Buffer</strong>: usage_count 可以增加到 5，越热的数据越不容易被逐出</li>
<li><strong>Ring Buffer</strong>: usage_count 最高为 1，避免 Ring 内 buffer 被误认为热数据</li>
</ul>
<hr>
<h2>7. 总结</h2>
<p>PostgreSQL 的 Buffer Ring 机制通过为特定操作（大表扫描、批量写入、VACUUM）分配私有缓冲区集合，实现了以下核心优势：</p>
<ol>
<li><strong>保护热数据</strong>: 大表扫描不会污染全局缓冲池</li>
<li><strong>提升性能</strong>: 减少锁竞争，加速缓冲区获取</li>
<li><strong>灵活配置</strong>: 不同场景使用不同大小的 Ring</li>
<li><strong>透明使用</strong>: 通过 ReadBufferExtended 的 strategy 参数无缝集成</li>
</ol>
<p>理解 Buffer Ring 机制对于优化 PostgreSQL 的大表查询、批量导入和维护操作具有重要意义。</p>
<hr>
<h2>参考文档</h2>
<ul>
<li>
<p>源码文件:</p>
<ul>
<li><code class="notranslate">src/backend/storage/buffer/freelist.c</code></li>
<li><code class="notranslate">src/backend/storage/buffer/bufmgr.c</code></li>
<li><code class="notranslate">src/include/storage/bufmgr.h</code></li>
<li><code class="notranslate">src/include/storage/buf_internals.h</code></li>
<li><code class="notranslate">src/backend/access/heap/heapam.c</code></li>
<li><code class="notranslate">src/backend/commands/copyfrom.c</code></li>
</ul>
</li>
<li>
<p>interdb</p>
</li>
<li>
<p><a href="https://www.interdb.jp/pg/pgsql08/05.html" rel="nofollow">https://www.interdb.jp/pg/pgsql08/05.html</a></p>
</li>
</ul></div>
<div style="font-size:small;margin-top:8px;float:right;">❤️ 转载文章请注明出处，谢谢！❤️</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://swrd.github.io">PGStone</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("12/07/2024"!=""){
    var startSite=new Date("12/07/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek main https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.disabled=true;
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","swrd/swrd.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>

</html>
